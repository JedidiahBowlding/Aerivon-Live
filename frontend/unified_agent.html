<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aerivon Command Center | The Unified Multimodal Agent Interface</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      height: 100%;
    }

    body {
      font-family: 'Georgia', serif;
      background: #0f0c1a;
      color: #e8dfc8;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      padding-bottom: env(safe-area-inset-bottom);
    }

    /* Top Bar */
    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1.5rem;
      background: rgba(255,255,255,0.03);
      border-bottom: 1px solid rgba(255,255,255,0.08);
      flex-wrap: wrap;
      gap: 1rem;
    }

    .top-bar-left {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }

    .logo-section {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .branding {
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
    }

    .logo {
      width: 32px;
      height: 32px;
      border-radius: 8px;
    }

    .title {
      font-size: 1.4rem;
      letter-spacing: 0.08em;
      background: linear-gradient(135deg, #c9a84c, #e8dfc8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      line-height: 1.3;
    }

    .subtitle {
      font-size: 0.65rem;
      color: #c9a84c;
      font-style: italic;
      opacity: 0.85;
      letter-spacing: 0.05em;
    }

    .state-badge {
      padding: 0.4rem 1rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .state-badge.idle {
      background: rgba(100,100,100,0.2);
      color: rgba(232,223,200,0.6);
    }

    .state-badge.listening {
      background: rgba(76,175,80,0.2);
      color: #81c784;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .state-badge.thinking {
      background: rgba(255,193,7,0.2);
      color: #ffd54f;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .state-badge.navigating {
      background: rgba(33,150,243,0.2);
      color: #64b5f6;
    }

    .state-badge.generating {
      background: rgba(156,39,176,0.2);
      color: #ba68c8;
    }

    .state-badge.speaking {
      background: rgba(255,87,34,0.2);
      color: #ff8a65;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .state-badge.done {
      background: rgba(76,175,80,0.2);
      color: #81c784;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .intent-chip {
      padding: 0.35rem 0.9rem;
      border-radius: 16px;
      font-size: 0.75rem;
      background: rgba(201,168,76,0.15);
      color: #c9a84c;
      border: 1px solid rgba(201,168,76,0.3);
    }

    .top-bar-right {
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }

    .icon-btn {
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      border: 1px solid rgba(201,168,76,0.3);
      background: rgba(255,255,255,0.03);
      color: #c9a84c;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s;
    }

    .icon-btn:hover {
      background: rgba(201,168,76,0.15);
      border-color: rgba(201,168,76,0.6);
    }

    .icon-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Main Layout */
    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
      min-height: 0;
    }

    /* Left Drawer */
    .left-drawer {
      width: 280px;
      background: rgba(255,255,255,0.02);
      border-right: 1px solid rgba(255,255,255,0.06);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      transition: transform 0.3s;
    }

    .left-drawer.collapsed {
      transform: translateX(-100%);
      position: absolute;
    }

    .drawer-section {
      padding: 1.25rem;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }

    .drawer-section h3 {
      font-size: 0.85rem;
      color: #c9a84c;
      margin-bottom: 0.75rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .drawer-section p {
      font-size: 0.8rem;
      line-height: 1.5;
      color: rgba(232,223,200,0.7);
    }

    .confidence-bar {
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      overflow: hidden;
      margin-top: 0.5rem;
    }

    .confidence-fill {
      height: 100%;
      background: linear-gradient(90deg, #c9a84c, #e8dfc8);
      transition: width 0.3s;
    }

    /* Center Stream */
    .center-stream {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    .stream-timeline {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 1.5rem;
      scroll-behavior: smooth;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .message-block {
      margin-bottom: 1.5rem;
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message-block.user {
      text-align: right;
    }

    .message-bubble {
      display: inline-block;
      max-width: 80%;
      padding: 0.9rem 1.2rem;
      border-radius: 12px;
      font-size: 0.95rem;
      line-height: 1.6;
    }

    .message-bubble.user {
      background: rgba(201,168,76,0.2);
      color: #e8dfc8;
      text-align: left;
    }

    .message-bubble.assistant {
      background: rgba(255,255,255,0.05);
      color: #e8dfc8;
      text-align: left;
    }

    .thinking-block {
      font-size: 0.85rem;
      color: rgba(232,223,200,0.5);
      font-style: italic;
      margin-bottom: 1rem;
      padding-left: 1.5rem;
      position: relative;
    }

    .thinking-block::before {
      content: "‚ãØ";
      position: absolute;
      left: 0;
      animation: thinking 1.5s ease-in-out infinite;
    }

    @keyframes thinking {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    .image-block {
      margin: 1rem 0;
      width: 100%;
      max-width: 100%;
      flex-shrink: 0;
    }

    .image-block img {
      width: 100%;
      height: auto;
      max-height: 500px;
      object-fit: contain;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      display: block;
    }

    .image-caption {
      font-size: 0.8rem;
      color: rgba(232,223,200,0.5);
      margin-top: 0.5rem;
      font-style: italic;
    }

    /* Composer */
    .composer {
      position: sticky;
      bottom: 0;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding: 1.25rem;
      background: #0f0c1a;
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
      z-index: 50;
      padding-bottom: calc(1.25rem + env(safe-area-inset-bottom));
    }

    .composer-input {
      flex: 1;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(201,168,76,0.3);
      border-radius: 8px;
      color: #e8dfc8;
      font-family: Georgia, serif;
      font-size: 16px;
      padding: 0.75rem 1rem;
      resize: none;
      min-height: 50px;
      max-height: 150px;
      outline: none;
      transition: border-color 0.2s;
    }

    .composer-input:focus {
      border-color: rgba(201,168,76,0.7);
    }

    .composer-input::placeholder {
      color: rgba(232,223,200,0.3);
      font-style: italic;
    }

    .composer-btn {
      padding: 0.75rem 1.4rem;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      background: linear-gradient(135deg, #c9a84c, #b8984a);
      color: #0f0c1a;
      transition: all 0.2s;
    }

    .composer-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(201,168,76,0.3);
    }

    .composer-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    #micBtn {
      font-size: 1.2rem;
      padding: 0.75rem 1rem;
    }

    #micBtn.recording {
      background: linear-gradient(135deg, #4caf50, #66bb6a);
      animation: pulse-mic 1s infinite;
      color: white;
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
    }

    #micBtn.live-mode {
      background: linear-gradient(135deg, #f44336, #e53935);
      animation: pulse-live 1.2s ease-in-out infinite;
      color: white;
      box-shadow: 0 0 25px rgba(244, 67, 54, 0.6);
    }

    @keyframes pulse-mic {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    @keyframes pulse-live {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.85; }
    }

    /* Right Panel */
    .right-panel {
      width: 320px;
      background: rgba(255,255,255,0.02);
      border-left: 1px solid rgba(255,255,255,0.06);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .panel-section {
      padding: 1.25rem;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }

    .panel-section h3 {
      font-size: 0.85rem;
      color: #c9a84c;
      margin-bottom: 0.75rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .screenshot-preview {
      width: 100%;
      border-radius: 8px;
      margin-bottom: 0.75rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .empty-state {
      text-align: center;
      padding: 2rem 1rem;
      color: rgba(232,223,200,0.4);
      font-size: 0.85rem;
      font-style: italic;
    }

    .home-link {
      display: inline-block;
      color: #c9a84c;
      text-decoration: none;
      font-size: 0.85rem;
      padding: 0.4rem 0.8rem;
      border: 1px solid rgba(201,168,76,0.3);
      border-radius: 6px;
      transition: all 0.2s;
    }

    .home-link:hover {
      background: rgba(201,168,76,0.15);
      border-color: rgba(201,168,76,0.6);
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .right-panel {
        width: 280px;
      }

      .left-drawer {
        width: 260px;
      }
    }

    @media (max-width: 768px) {
      body {
        font-size: 0.95rem;
      }

      .top-bar {
        padding: 0.5rem 1rem;
        flex-direction: column;
        align-items: stretch;
      }

      .top-bar-left,
      .top-bar-right {
        width: 100%;
        justify-content: space-between;
      }

      .top-bar-right {
        margin-top: 0.5rem;
        display: flex;
        gap: 0.5rem;
      }

      .title {
        font-size: 1.2rem;
      }

      .subtitle {
        font-size: 0.6rem;
      }

      .state-badge {
        font-size: 0.75rem;
        padding: 0.3rem 0.7rem;
      }

      .intent-chip {
        font-size: 0.75rem;
      }

      .main-container {
        flex-direction: column;
      }

      .left-drawer {
        position: fixed;
        top: 0;
        left: 0;
        height: 100%;
        width: 85%;
        max-width: 320px;
        z-index: 200;
        transform: translateX(-100%);
      }
      
      .left-drawer.collapsed {
        transform: translateX(-100%);
      }

      .left-drawer:not(.collapsed) {
        transform: translateX(0);
      }

      /* Convert right panel to bottom drawer on mobile */
      .right-panel {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 45vh;
        max-height: 60vh;
        background: #0f0c1a;
        border-left: none;
        border-top: 2px solid rgba(201,168,76,0.3);
        transform: translateY(85%);
        transition: transform 0.3s ease;
        z-index: 150;
        overflow-y: auto;
      }

      .right-panel::before {
        content: 'üì± UI Navigator & Actions (Tap to expand)';
        display: block;
        padding: 0.75rem 1rem;
        background: rgba(201,168,76,0.2);
        color: #c9a84c;
        font-size: 0.85rem;
        font-weight: 600;
        text-align: center;
        border-bottom: 1px solid rgba(255,255,255,0.06);
        cursor: pointer;
      }

      .right-panel.expanded {
        transform: translateY(0);
      }

      .right-panel.expanded::before {
        content: 'üì± UI Navigator & Actions (Tap to collapse)';
      }

      .message-bubble {
        max-width: 95%;
        font-size: 0.9rem;
        padding: 0.75rem 1rem;
      }

      .composer {
        padding: 0.75rem;
        gap: 0.5rem;
        flex-direction: column;
      }

      .composer-input {
        font-size: 16px;
        padding: 0.7rem;
        width: 100%;
      }

      .composer-btn {
        padding: 0.75rem 1.2rem;
        font-size: 1rem;
        width: 100%;
      }

      #micBtn {
        font-size: 1.3rem;
        width: 100%;
      }

      .icon-btn {
        font-size: 0.8rem;
        padding: 0.4rem 0.7rem;
      }
    }

    @media (max-width: 480px) {
      .logo {
        width: 28px;
        height: 28px;
      }

      .title {
        font-size: 1rem;
      }

      .subtitle {
        font-size: 0.55rem;
      }

      .stream-timeline {
        padding: 1rem;
      }

      .message-bubble {
        font-size: 0.85rem;
      }

      .composer {
        padding: 0.5rem;
        gap: 0.5rem;
      }

      .composer-input {
        min-height: 60px;
        font-size: 16px;
        width: 100%;
      }

      .composer-btn {
        padding: 0.65rem 1rem;
        font-size: 0.9rem;
        width: 100%;
      }

      #micBtn {
        font-size: 1.2rem;
        width: 100%;
      }

      .empty-state {
        font-size: 0.8rem;
        padding: 1.5rem 0.75rem;
      }

      .panel-section {
        padding: 1rem;
      }

      .panel-section h3 {
        font-size: 0.8rem;
      }

      .right-panel::before {
        font-size: 0.8rem;
        padding: 0.6rem 0.75rem;
      }
    }

    /* ================================
       WOW ADD-ONS (Wave + Elevation + Intent + Core Pulse)
    ================================ */

    /* --- Waveform --- */
    .wave-wrap{
      width: min(460px, 100%);
      height: 42px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(124,77,255,0.25);
      overflow: hidden;
      display: flex;
      align-items: center;
      padding: 0 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }

    #waveCanvas{
      width: 100%;
      height: 100%;
      display: block;
    }

    /* On mobile, make it full width and sit nicely */
    @media (max-width: 768px){
      .wave-wrap{ width: 100%; }
    }

    /* --- Elevation transitions by state (smooth "Material" lift) --- */
    :root{
      --elev-0: 0 0 0 rgba(0,0,0,0);
      --elev-1: 0 8px 24px rgba(0,0,0,0.35);
      --elev-2: 0 14px 40px rgba(0,0,0,0.55);
      --elev-3: 0 18px 54px rgba(0,0,0,0.65);
    }

    /* Apply elevation to surfaces */
    .top-bar,
    .composer,
    .left-drawer,
    .right-panel{
      transition: box-shadow 280ms cubic-bezier(0.4,0,0.2,1),
                  transform 280ms cubic-bezier(0.4,0,0.2,1);
      box-shadow: var(--elev-1);
    }

    /* State-based lift */
    body[data-state="IDLE"] .top-bar,
    body[data-state="IDLE"] .composer { box-shadow: var(--elev-1); }

    body[data-state="LISTENING"] .top-bar,
    body[data-state="LISTENING"] .composer { box-shadow: var(--elev-2); transform: translateY(-1px); }

    body[data-state="THINKING"] .top-bar,
    body[data-state="THINKING"] .composer { box-shadow: var(--elev-2); }

    body[data-state="SPEAKING"] .top-bar,
    body[data-state="SPEAKING"] .composer { box-shadow: var(--elev-3); transform: translateY(-2px); }

    /* --- Intent chip slide-in --- */
    .intent-chip{
      opacity: 0;
      transform: translateY(-8px) scale(0.98);
      transition: opacity 240ms cubic-bezier(0.4,0,0.2,1),
                  transform 240ms cubic-bezier(0.4,0,0.2,1);
      will-change: transform, opacity;
    }

    .intent-chip.show{
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    /* --- AI core pulse background on speaking --- */
    body::after{
      content:"";
      position: fixed;
      inset: -40vmax;
      pointer-events: none;
      opacity: 0;
      background:
        radial-gradient(circle at 35% 20%,
          rgba(0,229,255,0.20),
          rgba(124,77,255,0.10) 25%,
          transparent 60%);
      filter: blur(30px);
      transition: opacity 280ms cubic-bezier(0.4,0,0.2,1);
    }

    body.core-pulse::after{
      opacity: 1;
      animation: corePulse 2.1s ease-in-out infinite;
    }

    @keyframes corePulse{
      0%,100% { transform: scale(1); opacity: 0.85; }
      50%     { transform: scale(1.06); opacity: 1; }
    }
  </style>
</head>
<body>
  <!-- Top Bar -->
  <div class="top-bar">
    <div class="top-bar-left">
      <div class="logo-section">
        <img class="logo" src="./assets/favicon.png" alt="Aerivon" />
        <div class="branding">
          <h1 class="title">Command Center</h1>
          <p class="subtitle">The Unified Multimodal Agent Interface</p>
        </div>
      </div>
      <div class="state-badge idle" id="stateBadge">
        <span id="stateIndicator">‚óè</span>
        <span id="stateText">IDLE</span>
      </div>
      <div class="intent-chip" id="intentChip" style="display: none;">
        Intent: <span id="intentText">AUTO</span> (<span id="intentConfidence">0.0</span>)
      </div>
    </div>
    <div class="top-bar-right">
      <a href="./" class="home-link">‚Üê Home</a>
      <button class="icon-btn" id="toggleDrawer">üìä Debug</button>
      <button class="icon-btn" id="clearBtn">üóë Clear</button>
    </div>
  </div>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Left Drawer -->
    <div class="left-drawer collapsed" id="leftDrawer">
      <div class="drawer-section">
        <h3>Intent Detection</h3>
        <p id="intentReason">No intent detected yet</p>
        <div class="confidence-bar">
          <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
        </div>
      </div>
      <div class="drawer-section">
        <h3>Session Info</h3>
        <p id="sessionInfo">Not connected</p>
      </div>
      <div class="drawer-section">
        <h3>Memory Scope</h3>
        <p id="memoryScope">aerivon_global</p>
      </div>
      <div class="drawer-section">
        <h3>Debug Log</h3>
        <div id="debugLog" style="font-size: 0.75rem; max-height: 200px; overflow-y: auto;"></div>
      </div>
    </div>

    <!-- Center Stream -->
    <div class="center-stream">
      <div class="stream-timeline" id="timeline">
        <div class="empty-state">
          üëã Welcome to Aerivon Command Center!<br><br>
          I can help you with:<br>
          ‚Ä¢ üé§ Voice conversations (click mic for automatic turn-taking)<br>
          ‚Ä¢ üí¨ Natural text chat<br>
          ‚Ä¢ üåê Web navigation & automation<br>
          ‚Ä¢ üìñ Illustrated story generation<br><br>
          Speak or type a message below to get started.
        </div>
      </div>

      <!-- Composer -->
      <div class="composer">
        <textarea 
          class="composer-input" 
          id="messageInput" 
          placeholder="Type your message or CLICK üé§ for LIVE conversation (automatic turn-taking)..."
          rows="2"
        ></textarea>

        <!-- Waveform visualizer -->
        <div class="wave-wrap" aria-hidden="true">
          <canvas id="waveCanvas" width="420" height="42"></canvas>
        </div>

        <button class="composer-btn" id="micBtn" title="Click to start live conversation">üé§</button>
        <button class="composer-btn" id="sendBtn">Send</button>
      </div>
    </div>

    <!-- Right Panel -->
    <div class="right-panel">
      <div class="panel-section">
        <h3>UI Navigator Proof</h3>
        <div id="screenshotArea">
          <p class="empty-state">Screenshot will appear here when navigating</p>
        </div>
      </div>
      <div class="panel-section">
        <h3>Action Plan</h3>
        <div id="actionPlan">
          <p class="empty-state">Actions will be listed here</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Configuration
    function getBackendHttpBase() {
      // If the hosting server injected a backend base (Cloud Run hosted frontend), prefer it.
      try {
        const injected = (window && window.AERIVON_BACKEND_BASE) ? String(window.AERIVON_BACKEND_BASE).trim() : '';
        if (injected) return injected.replace(/\/$/, '');
      } catch {
        // ignore
      }

      // Allow overriding backend base via query param for Cloud Run deployments.
      try {
        const urlParams = new URLSearchParams(window.location.search);
        const qp = (urlParams.get('backend') || '').trim();
        if (qp) return qp.replace(/\/$/, '');
      } catch {
        // ignore
      }

      // Auto-detect: if the frontend itself is hosted on Cloud Run, connect to backend.
      if (/\.run\.app$/i.test(location.hostname)) {
        const backendHost = location.hostname.replace(/frontend/i, 'agent');
        return `${location.protocol}//${backendHost}`;
      }

      // Local/dev default.
      return `${location.protocol}//${location.hostname}:8081`;
    }

    function httpBaseToWsBase(httpBase) {
      const base = String(httpBase || '').trim();
      if (!base) return '';
      return base.replace(/^https:/i, 'wss:').replace(/^http:/i, 'ws:');
    }

    const backendBase = getBackendHttpBase();
    const WS_URL = `${httpBaseToWsBase(backendBase)}/ws/aerivon`;

    // State
    let ws = null;
    let sessionId = null;
    let isConnected = false;

    // DOM Elements
    const timeline = document.getElementById('timeline');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const micBtn = document.getElementById('micBtn');
    const stateBadge = document.getElementById('stateBadge');
    const stateText = document.getElementById('stateText');
    const intentChip = document.getElementById('intentChip');
    const intentText = document.getElementById('intentText');
    const intentConfidence = document.getElementById('intentConfidence');
    const intentReason = document.getElementById('intentReason');
    const confidenceFill = document.getElementById('confidenceFill');
    const sessionInfo = document.getElementById('sessionInfo');
    const memoryScope = document.getElementById('memoryScope');
    const debugLog = document.getElementById('debugLog');

    // Audio state
    let audioCtx = null;
    let micStream = null;
    let processor = null;
    let sourceNode = null;
    let isRecording = false;
    let isLiveMode = false; // Live conversation mode (stays on)
    const TARGET_SAMPLE_RATE = 16000;
    const toggleDrawer = document.getElementById('toggleDrawer');
    const clearBtn = document.getElementById('clearBtn');
    const rightPanel = document.querySelector('.right-panel');

    // Voice Activity Detection (VAD) state
    let vadSilenceThreshold = 0.01; // Energy threshold for silence
    let vadSilenceDuration = 800; // ms of silence before sending audio_end
    let vadSpeakingDuration = 300; // ms of speaking before interrupting agent
    let lastSpeechTime = 0;
    let silenceTimer = null;
    let isSpeaking = false;
    let isAgentSpeaking = false;

    // ---- Waveform (RMS) visualizer state ----
    const waveCanvas = document.getElementById('waveCanvas');
    const waveCtx = waveCanvas ? waveCanvas.getContext('2d') : null;
    let waveHistory = new Array(80).fill(0); // rolling RMS values
    let waveAnimId = null;
    let lastRms = 0;

    // ---- State tracking for transitions / sounds ----
    let lastUiState = 'IDLE';

    // Make right panel expandable on mobile
    if (rightPanel) {
      rightPanel.addEventListener('click', (e) => {
        // Allow tap anywhere on mobile
        if (window.innerWidth <= 768) {
          rightPanel.classList.toggle('expanded');
        }
      });
    }

    // Event Listeners
    sendBtn.addEventListener('click', () => {
      unlockAudio();
      sendMessage();
    });
    
    messageInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        unlockAudio();
        sendMessage();
      }
    });
    
    // Microphone toggle function - switches to live mode
    function toggleRecording() {
      unlockAudio();
      if (isLiveMode) {
        // End live mode
        isLiveMode = false;
        if (isRecording) {
          stopRecording();
          // Send audio_end when exiting live mode
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'audio_end' }));
          }
        }
        micBtn.classList.remove('live-mode');
        micBtn.title = 'Click to start live conversation';
        addDebugLog('üî¥ Live mode ended');
        updateState('IDLE');
      } else {
        // Start live mode
        isLiveMode = true;
        startRecording();
        micBtn.classList.add('live-mode');
        micBtn.title = 'Click to end live conversation (auto VAD active)';
        addDebugLog('üü¢ Live mode started - automatic turn-taking enabled!');
        updateState('LISTENING');
      }
    }
    
    // Microphone event listeners (click to toggle)
    micBtn.addEventListener('click', toggleRecording);
    
    toggleDrawer.addEventListener('click', () => {
      leftDrawer.classList.toggle('collapsed');
    });
    clearBtn.addEventListener('click', clearTimeline);

    // Audio utility functions
    function downsampleBuffer(buffer, fromRate, toRate) {
      if (fromRate === toRate) return buffer;
      const ratio = fromRate / toRate;
      const newLength = Math.round(buffer.length / ratio);
      const result = new Float32Array(newLength);
      let offsetResult = 0;
      let offsetBuffer = 0;
      while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
        let accum = 0;
        let count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
          accum += buffer[i];
          count++;
        }
        result[offsetResult] = accum / count;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
      }
      return result;
    }

    function floatTo16BitPCM(float32Array) {
      const int16 = new Int16Array(float32Array.length);
      for (let i = 0; i < float32Array.length; i++) {
        const val = Math.max(-1, Math.min(1, float32Array[i]));
        int16[i] = val < 0 ? val * 0x8000 : val * 0x7fff;
      }
      return int16;
    }

    function u8ToB64(u8) {
      let binary = '';
      for (let i = 0; i < u8.byteLength; i++) {
        binary += String.fromCharCode(u8[i]);
      }
      return btoa(binary);
    }

    // Voice Activity Detection - calculate RMS energy
    function calculateRMS(audioData) {
      let sum = 0;
      for (let i = 0; i < audioData.length; i++) {
        sum += audioData[i] * audioData[i];
      }
      return Math.sqrt(sum / audioData.length);
    }

    // Handle voice activity detection
    function handleVAD(rms) {
      if (!isLiveMode) return;

      const now = Date.now();
      const wasSpeaking = isSpeaking;
      isSpeaking = rms > vadSilenceThreshold;

      if (isSpeaking) {
        lastSpeechTime = now;
        
        // Clear any pending silence timer
        if (silenceTimer) {
          clearTimeout(silenceTimer);
          silenceTimer = null;
        }

        // If user starts speaking while agent is talking, interrupt the agent
        if (isAgentSpeaking && !wasSpeaking) {
          stopStoryAudio();
          isAgentSpeaking = false;
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'interrupt' }));
          }
          addDebugLog('üî¥ Interrupted agent - you started speaking');
          updateState('LISTENING');
        }

        if (!wasSpeaking) {
          addDebugLog('üéôÔ∏è Speaking detected');
          updateState('LISTENING');
        }
      } else {
        // User is silent
        if (wasSpeaking) {
          // User just stopped speaking - start silence timer
          addDebugLog('ü§´ Silence detected, waiting...');
          
          if (silenceTimer) clearTimeout(silenceTimer);
          
          silenceTimer = setTimeout(() => {
            if (isLiveMode && ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'audio_end' }));
              addDebugLog('‚úÖ Silence confirmed - agent\'s turn');
              updateState('THINKING');
            }
            silenceTimer = null;
          }, vadSilenceDuration);
        }
      }
    }

    // Start recording audio
    async function startRecording() {
      if (isRecording || !isConnected) return;

      try {
        isRecording = true;
        micBtn.classList.add('recording');
        addDebugLog('üé§ Microphone active');

        // Get microphone access
        micStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            channelCount: 1,
          },
        });

        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        sourceNode = audioCtx.createMediaStreamSource(micStream);
        processor = audioCtx.createScriptProcessor(4096, 1, 1);

        processor.onaudioprocess = (e) => {
          if (!ws || ws.readyState !== WebSocket.OPEN || !isRecording) return;

          const input = e.inputBuffer.getChannelData(0);
          
          // Voice Activity Detection
          if (isLiveMode) {
            const rms = calculateRMS(input);
            handleVAD(rms);
            
            // ---- WOW: Push RMS to waveform visualizer ----
            pushRms(rms);
          }
          
          const downsampled = downsampleBuffer(input, audioCtx.sampleRate, TARGET_SAMPLE_RATE);
          const int16 = floatTo16BitPCM(downsampled);
          const u8 = new Uint8Array(int16.buffer);

          ws.send(JSON.stringify({
            type: 'audio',
            mime_type: 'audio/pcm',
            data_b64: u8ToB64(u8),
          }));
        };

        sourceNode.connect(processor);
        processor.connect(audioCtx.destination);

      } catch (err) {
        console.error('Microphone error:', err);
        addDebugLog('‚ùå Microphone error: ' + err.message);
        isRecording = false;
        micBtn.classList.remove('recording');
      }
    }

    // Stop recording audio
    function stopRecording() {
      if (!isRecording) return;

      isRecording = false;
      micBtn.classList.remove('recording');
      addDebugLog('üé§ Microphone stopped');

      // Clear VAD timers
      if (silenceTimer) {
        clearTimeout(silenceTimer);
        silenceTimer = null;
      }
      isSpeaking = false;
      isAgentSpeaking = false;

      // Only send audio_end if NOT in live mode
      // In live mode, we keep the session open for continuous interaction
      if (!isLiveMode && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'audio_end' }));
      }

      // Clean up audio resources
      if (processor) {
        processor.disconnect();
        processor = null;
      }
      if (sourceNode) {
        sourceNode.disconnect();
        sourceNode = null;
      }
      if (micStream) {
        micStream.getTracks().forEach(track => track.stop());
        micStream = null;
      }
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }
    }

    // Connect to WebSocket
    function connect() {
      console.log('üîå Connecting to:', WS_URL);
      addDebugLog('Connecting to ' + WS_URL);
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        isConnected = true;
        console.log('‚úÖ WebSocket connected successfully');
        addDebugLog('Connected');
        updateSessionInfo('Connected');
        
        // Send start message
        ws.send(JSON.stringify({
          type: 'start',
          user_id: 'demo_user',
          memory_scope: 'aerivon_global'
        }));
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleMessage(data);
        } catch (e) {
          console.error('Failed to parse message:', e);
        }
      };

      ws.onerror = (error) => {
        console.error('‚ùå WebSocket error:', error);
        addDebugLog('Error: ' + error.message);
      };

      ws.onclose = () => {
        isConnected = false;
        console.log('üîå WebSocket disconnected');
        updateSessionInfo('Disconnected');
        addDebugLog('Disconnected');
        stopStoryAudio();
        setTimeout(() => connect(), 3000);
      };
    }

    // Handle incoming messages
    function handleMessage(data) {
      addDebugLog(`‚Üê ${data.type}`);

      switch (data.type) {
        case 'status':
          updateState(data.state);
          if (data.session_id) {
            sessionId = data.session_id;
            updateSessionInfo(`Session: ${sessionId}`);
          }
          break;

        case 'thinking':
          addThinkingBlock(data.text);
          break;

        case 'intent':
          updateIntent(data);
          break;

        case 'text':
          addAssistantText(data.text);
          break;

        case 'image':
          addImage(data.data_b64, data.mime_type, data.index);
          break;

        case 'audio':
          console.log('üìª Received audio message:', { 
            sampleRate: data.sample_rate || 24000, 
            base64Length: data.data_b64?.length || 0,
            mimeType: data.mime_type
          });
          isAgentSpeaking = true;
          updateState('SPEAKING');
          playAudio(data.data_b64, data.sample_rate || 24000);
          break;

        case 'screenshot':
          updateScreenshot(data.data_b64, data.mime_type, data.url);
          break;

        case 'actions':
          updateActionPlan(data.plan, data.step);
          break;

        case 'action_result':
          updateActionResult(data.index, data.result);
          break;

        case 'done':
          // Story complete - remove thinking blocks and finalize
          removeThinkingBlocks();
          finalizeAssistantMessage();
          isAgentSpeaking = false;
          updateState('IDLE');
          break;

        case 'error':
          addErrorMessage(data.error);
          isAgentSpeaking = false;
          updateState('IDLE');
          break;

        case 'interrupted':
          addSystemMessage('Interrupted by ' + data.source);
          break;
      }
    }

    // Send message
    function sendMessage() {
      const text = messageInput.value.trim();
      console.log('sendMessage called:', { text, isConnected, wsState: ws?.readyState });
      
      if (!text) {
        console.warn('Send aborted: empty text');
        return;
      }
      
      if (!isConnected) {
        console.warn('Send aborted: not connected');
        addErrorMessage('Not connected to server. Please wait or refresh the page.');
        return;
      }

      addUserMessage(text);
      
      console.log('Sending message:', { type: 'text', text });
      ws.send(JSON.stringify({
        type: 'text',
        text: text
      }));

      messageInput.value = '';
      messageInput.style.height = 'auto';
    }

    // ============ WOW: Waveform visualizer functions ============
    function resizeWaveCanvasToCss() {
      if (!waveCanvas) return;
      const dpr = window.devicePixelRatio || 1;
      const rect = waveCanvas.getBoundingClientRect();
      waveCanvas.width = rect.width * dpr;
      waveCanvas.height = rect.height * dpr;
      waveCtx.scale(dpr, dpr);
    }

    function pushRms(rms) {
      // Normalize typical RMS range 0..0.2 ‚Üí 0..1
      let normalized = (rms / 0.2) * 1.2;
      normalized = Math.min(normalized, 1);
      
      // Power curve for punchier visual
      normalized = Math.pow(normalized, 0.75);
      
      // Smooth
      lastRms = lastRms * 0.92 + normalized * 0.08;
      
      // Shift array left, add new value
      waveHistory.shift();
      waveHistory.push(lastRms);
      
      // Draw
      drawWaveform();
    }

    function drawWaveform() {
      if (!waveCanvas || !waveCtx) return;
      const w = waveCanvas.width / (window.devicePixelRatio || 1);
      const h = waveCanvas.height / (window.devicePixelRatio || 1);
      
      waveCtx.clearRect(0, 0, w, h);
      
      const barCount = waveHistory.length;
      const barWidth = (w / barCount) * 0.8;
      const gap = (w / barCount) * 0.2;
      const midY = h / 2;
      
      waveCtx.fillStyle = 'rgba(0,229,255,0.85)';
      
      for (let i = 0; i < barCount; i++) {
        const x = i * (barWidth + gap);
        const val = waveHistory[i];
        const barHeight = val * midY * 0.9;
        
        // Primary trace
        waveCtx.fillRect(x, midY - barHeight, barWidth, barHeight);
        // Mirror trace
        waveCtx.fillRect(x, midY, barWidth, barHeight * 0.6);
      }
      
      // Request next frame if actively recording
      if (isRecording) {
        waveAnimId = requestAnimationFrame(drawWaveform);
      }
    }

    // Listen for window resize
    window.addEventListener('resize', () => {
      resizeWaveCanvasToCss();
      drawWaveform();
    });

    // ============ WOW: Listening chime (on state transition) ============
    function playListeningChime() {
      if (!audioCtx || audioCtx.state === 'suspended') return;
      
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      osc.type = 'sine';
      osc.frequency.setValueAtTime(880, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.08);
      
      gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.12);
      
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      
      osc.start();
      osc.stop(audioCtx.currentTime + 0.12);
    }

    // UI Update Functions
    function updateState(state) {
      stateText.textContent = state;
      stateBadge.className = `state-badge ${state.toLowerCase()}`;
      
      // ---- WOW: Add data-state attribute for elevation transitions ----
      document.body.setAttribute('data-state', state);
      
      // ---- WOW: Toggle core-pulse class when SPEAKING ----
      if (state === 'SPEAKING') {
        document.body.classList.add('core-pulse');
      } else {
        document.body.classList.remove('core-pulse');
      }
      
      // ---- WOW: Play listening chime on state change ----
      if (state !== lastUiState) {
        if (state === 'LISTENING' || state === 'THINKING') {
          playListeningChime();
        }
        lastUiState = state;
      }
    }

    function updateIntent(data) {
      intentChip.style.display = 'inline-flex';
      intentText.textContent = data.intent.toUpperCase();
      intentConfidence.textContent = data.confidence.toFixed(2);
      intentReason.textContent = data.reason || 'No reason provided';
      confidenceFill.style.width = (data.confidence * 100) + '%';
      
      // ---- WOW: Slide-in animation for intent chip ----
      requestAnimationFrame(() => {
        intentChip.classList.add('show');
      });
    }

    function updateSessionInfo(info) {
      sessionInfo.textContent = info;
    }

    function addDebugLog(message) {
      const entry = document.createElement('div');
      entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
      entry.style.marginBottom = '0.3rem';
      debugLog.appendChild(entry);
      debugLog.scrollTop = debugLog.scrollHeight;
    }

    // Message Blocks
    function addUserMessage(text) {
      const block = document.createElement('div');
      block.className = 'message-block user';
      block.innerHTML = `<div class="message-bubble user">${escapeHtml(text)}</div>`;
      appendToTimeline(block);
    }

    let currentAssistantBlock = null;

    function addAssistantText(text) {
      if (!currentAssistantBlock) {
        currentAssistantBlock = document.createElement('div');
        currentAssistantBlock.className = 'message-block';
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble assistant';
        currentAssistantBlock.appendChild(bubble);
        appendToTimeline(currentAssistantBlock);
      }

      const bubble = currentAssistantBlock.querySelector('.message-bubble');
      bubble.textContent += text;
      timeline.scrollTop = timeline.scrollHeight;
    }

    function finalizeAssistantMessage() {
      currentAssistantBlock = null;
    }

    function addThinkingBlock(text) {
      // Remove any existing thinking blocks first
      const existingThinking = timeline.querySelectorAll('.thinking-block');
      existingThinking.forEach(block => block.remove());
      
      const block = document.createElement('div');
      block.className = 'thinking-block';
      block.textContent = text;
      appendToTimeline(block);
    }

    function removeThinkingBlocks() {
      const thinkingBlocks = timeline.querySelectorAll('.thinking-block');
      thinkingBlocks.forEach(block => block.remove());
    }

    function addImage(dataB64, mimeType, index) {
      finalizeAssistantMessage();
      
      const block = document.createElement('div');
      block.className = 'image-block';
      block.innerHTML = `
        <img src="data:${mimeType};base64,${dataB64}" alt="Generated image ${index}" />
        <div class="image-caption">Image ${index}</div>
      `;
      appendToTimeline(block);
    }

    function addErrorMessage(error) {
      const block = document.createElement('div');
      block.className = 'message-block';
      block.innerHTML = `<div class="message-bubble assistant" style="border-left: 3px solid #f44336;">‚ùå Error: ${escapeHtml(error)}</div>`;
      appendToTimeline(block);
    }

    function addSystemMessage(message) {
      const block = document.createElement('div');
      block.className = 'thinking-block';
      block.textContent = '‚ö†Ô∏è ' + message;
      appendToTimeline(block);
    }

    function updateScreenshot(dataB64, mimeType, url) {
      const screenshotArea = document.getElementById('screenshotArea');
      if (!screenshotArea) return;
      
      screenshotArea.innerHTML = `
        <img src="data:${mimeType};base64,${dataB64}" style="width: 100%; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);" alt="Browser Screenshot" />
        <div style="font-size: 0.7rem; color: rgba(232,223,200,0.5); margin-top: 0.5rem; word-break: break-all;">${escapeHtml(url || '')}</div>
      `;
    }

    function updateActionPlan(plan, step) {
      const actionPlanDiv = document.getElementById('actionPlan');
      if (!actionPlanDiv) return;
      
      const actions = plan.actions || [];
      const note = plan.note || '';
      const done = plan.done || false;
      
      let html = `<div style="font-size: 0.75rem; color: #c9a84c; margin-bottom: 0.5rem; font-weight: 600;">Step ${step}</div>`;
      
      if (note) {
        html += `<div style="font-size: 0.8rem; color: rgba(232,223,200,0.7); margin-bottom: 0.75rem; font-style: italic;">${escapeHtml(note)}</div>`;
      }
      
      if (actions.length > 0) {
        html += '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
        actions.forEach((action, idx) => {
          const actionType = action.action || 'unknown';
          const actionText = action.text || action.query || action.url || '';
          html += `
            <div id="action-${idx}" style="padding: 0.5rem; background: rgba(255,255,255,0.03); border-radius: 6px; border-left: 3px solid rgba(201,168,76,0.5);">
              <div style="font-size: 0.75rem; color: #c9a84c; font-weight: 600;">${idx + 1}. ${escapeHtml(actionType.toUpperCase())}</div>
              ${actionText ? `<div style="font-size: 0.75rem; color: rgba(232,223,200,0.6); margin-top: 0.25rem;">${escapeHtml(actionText)}</div>` : ''}
              <div id="action-status-${idx}" style="font-size: 0.7rem; color: rgba(232,223,200,0.4); margin-top: 0.25rem;">‚è≥ Pending...</div>
            </div>
          `;
        });
        html += '</div>';
      }
      
      if (done) {
        html += '<div style="font-size: 0.75rem; color: #81c784; margin-top: 0.75rem; font-weight: 600;">‚úì Task Complete</div>';
      }
      
      actionPlanDiv.innerHTML = html;
    }

    function updateActionResult(index, result) {
      const statusDiv = document.getElementById(`action-status-${index}`);
      if (!statusDiv) return;
      
      const success = result.success !== false;
      const message = result.message || result.error || '';
      
      if (success) {
        statusDiv.innerHTML = `<span style="color: #81c784;">‚úì ${escapeHtml(message || 'Done')}</span>`;
      } else {
        statusDiv.innerHTML = `<span style="color: #f44336;">‚úó ${escapeHtml(message || 'Failed')}</span>`;
      }
    }

    function appendToTimeline(block) {
      // Remove empty state if present
      const emptyState = timeline.querySelector('.empty-state');
      if (emptyState) {
        emptyState.remove();
      }
      
      timeline.appendChild(block);
      
      // Smooth scroll to bottom with slight delay to ensure content is rendered
      requestAnimationFrame(() => {
        timeline.scrollTo({
          top: timeline.scrollHeight,
          behavior: 'smooth'
        });
      });
    }

    // Audio playback for narration (using story.html implementation)
    let storyAudioCtx = null;
    let storyPlayCursor = 0;
    let storyActiveSources = [];
    let audioUnlocked = false;

    function ensureStoryAudioCtx() {
      if (storyAudioCtx) return;
      storyAudioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
      storyPlayCursor = storyAudioCtx.currentTime;
      console.log('üîä Audio context created');
    }

    // Unlock audio on first user interaction
    function unlockAudio() {
      if (audioUnlocked) return;
      ensureStoryAudioCtx();
      
      if (storyAudioCtx.state === 'suspended') {
        storyAudioCtx.resume().then(() => {
          console.log('üîì Audio context unlocked');
          audioUnlocked = true;
        });
      } else {
        audioUnlocked = true;
      }
    }

    async function playAudio(base64Data, sampleRate) {
      console.log('üîä Received audio chunk, sample rate:', sampleRate, 'length:', base64Data.length);
      
      try {
        ensureStoryAudioCtx();
        
        // Decode base64 to raw PCM16 bytes
        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        
        // Convert PCM16 to Float32 for Web Audio API
        const int16 = new Int16Array(bytes.buffer);
        const float32 = new Float32Array(int16.length);
        for (let i = 0; i < int16.length; i++) {
          float32[i] = int16[i] / 32768.0;
        }
        
        // Resume context if suspended (required by some browsers)
        if (storyAudioCtx.state === 'suspended') {
          await storyAudioCtx.resume();
          console.log('‚ñ∂Ô∏è Audio context resumed');
        }
        
        // Create audio buffer with the correct sample rate
        const buffer = storyAudioCtx.createBuffer(1, float32.length, sampleRate);
        buffer.copyToChannel(float32, 0);
        
        // Schedule playback with proper timing (key improvement from story.html)
        const src = storyAudioCtx.createBufferSource();
        src.buffer = buffer;
        src.connect(storyAudioCtx.destination);
        
        const startAt = Math.max(storyPlayCursor, storyAudioCtx.currentTime + 0.05);
        src.start(startAt);
        storyPlayCursor = startAt + buffer.duration;
        storyActiveSources.push(src);
        
        src.onended = () => {
          storyActiveSources = storyActiveSources.filter(s => s !== src);
          // If all audio chunks have finished playing, agent is done speaking
          if (storyActiveSources.length === 0) {
            isAgentSpeaking = false;
            if (isLiveMode) {
              addDebugLog('üéß Agent finished speaking - your turn');
              updateState('LISTENING');
            }
          }
        };
        
        console.log('‚ñ∂Ô∏è Scheduled audio chunk, duration:', buffer.duration.toFixed(2), 's, startAt:', startAt.toFixed(2), 's');
        
        // Add visual indicator for first chunk
        if (storyActiveSources.length === 1) {
          addSystemMessage('üîä Narrating...');
        }
      } catch (e) {
        console.error('‚ùå Audio playback error:', e);
      }
    }

    function stopStoryAudio() {
      storyActiveSources.forEach(s => { try { s.stop(); } catch {} });
      storyActiveSources = [];
      if (storyAudioCtx) storyPlayCursor = storyAudioCtx.currentTime;
      console.log('‚èπ Audio playback stopped');
    }

    function clearTimeline() {
      timeline.innerHTML = '<div class="empty-state">Timeline cleared. Start a new conversation!</div>';
      currentAssistantBlock = null;
      stopStoryAudio();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Initialize
    // ---- WOW: Initialize waveform canvas ----
    if (waveCanvas) {
      resizeWaveCanvasToCss();
      drawWaveform();
    }
    
    connect();
  </script>
</body>
</html>
